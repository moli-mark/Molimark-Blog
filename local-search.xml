<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ThreadLocal原理详解</title>
    <link href="/2025/06/29/ThreadLocal%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
    <url>/2025/06/29/ThreadLocal%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="ThreadLocal介绍"><a href="#ThreadLocal介绍" class="headerlink" title="ThreadLocal介绍"></a>ThreadLocal介绍</h1><h2 id="什么是ThreadLocal"><a href="#什么是ThreadLocal" class="headerlink" title="什么是ThreadLocal"></a>什么是ThreadLocal</h2><p>首先，它是一个数据结构，有点像HashMap，可以保存”key : value”键值对，但是一个ThreadLocal只能保存一个，并且各个线程的数据互不干扰</p><h2 id="ThreadLocal和Synchonized"><a href="#ThreadLocal和Synchonized" class="headerlink" title="ThreadLocal和Synchonized"></a>ThreadLocal和Synchonized</h2><p>两者都用于解决多线程并发访问。但是ThreadLocal与synchronized有本质的区别。Synchronized用于线程间的数据共享，而ThreadLocal则用于线程间的数据隔离。Synchronized是利用锁的机制，使变量或代码块在某一时该只能被一个线程访问。而ThreadLocal为每一个线程都提供了变量的副本，使得每个线程在某一时间访问到的并不是同一个对象，这样就隔离了多个线程对数据的数据共享。而Synchronized却正好相反，它用于在多个线程间通信时能够获得数据共享</p><h2 id="ThreadLocal中的key和value"><a href="#ThreadLocal中的key和value" class="headerlink" title="ThreadLocal中的key和value"></a>ThreadLocal中的key和value</h2><p>ThreadLocal实例的弱引用对象会作为key存放在线程的ThreadLocalMap中，然后set方法加入的值就作为ThreadLocalMap中的value，一个线程中可以new多个ThreadLocal用于存放多个值，这些值在线程内是共享的</p><h1 id="为什么要用ThreadLocal保存登录信息？有什么优缺点？"><a href="#为什么要用ThreadLocal保存登录信息？有什么优缺点？" class="headerlink" title="为什么要用ThreadLocal保存登录信息？有什么优缺点？"></a>为什么要用ThreadLocal保存登录信息？有什么优缺点？</h1><p>假设用户登录时请求会被拦截器拦截，提取出当前token中的用户信息（比如userId）放入Context类中。假如userId用的是String类型，那么在高并发的时候，用户A访问系统，此时userId存的是A的userId，如果此时用户B也访问系统，那么userId会被设置成B的userId，此时如果A的业务中需要使用userId，那么拿到的将会是B的userId</p><p>优点：</p><ol><li>线程隔离：每个线程都有自己独立的变量副本，不会受到其他线程的影响，可以避免线程安全问题</li><li>高效性：由于每个线程都有自己的变量副本，不需要进行额外的同步操作，可以提高程序的执行效率</li><li>简单易用：使用 ThreadLocal 可以方便地在多线程环境下管理登录信息，不需要手动进行线程间的变量传递</li></ol><p>缺点：</p><ol><li>内存泄漏：如果没有及时清理 ThreadLocal 中的变量副本，可能会导致内存泄漏问题。因为 ThreadLocal 中的变量副本是与线程绑定的，如果线程一直存在，那么对应的变量副本也会一直存在，可能会占用大量的内存空间</li><li>上下文切换问题：由于每个线程都有自己的变量副本，当需要在多个线程之间共享数据时，可能需要进行额外的上下文切换操作，增加了程序的复杂性和开销</li></ol><h1 id="ThreadLocal的内存泄露问题"><a href="#ThreadLocal的内存泄露问题" class="headerlink" title="ThreadLocal的内存泄露问题"></a>ThreadLocal的内存泄露问题</h1><h2 id="强引用与弱引用"><a href="#强引用与弱引用" class="headerlink" title="强引用与弱引用"></a>强引用与弱引用</h2><p><strong>强引用</strong>，使用最普遍的引用，一个对象具有强引用，不会被垃圾回收器回收。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不回收这种对象</p><p><strong>如果想取消强引用和某个对象之间的关联，可以显式地将引用赋值为null，这样JVM在合适的时间就会回收该对象</strong></p><p><strong>弱引用</strong>，JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在java中，用java.lang.ref.WeakReference类来表示。可以在缓存中使用弱引用</p><h2 id="GC如何找到需要回收的对象"><a href="#GC如何找到需要回收的对象" class="headerlink" title="GC如何找到需要回收的对象"></a>GC如何找到需要回收的对象</h2><p>JVM如何找到需要回收的对象，方式有两种：</p><ul><li>引用计数法：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收</li><li>可达性分析法：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的，那么虚拟机就判断是可回收对象</li></ul><blockquote><p>引用计数法，可能会出现A 引用了 B，B 又引用了 A，这时候就算他们都不再使用了，但因为相互引用 计数器&#x3D;1 永远无法被回收</p></blockquote><h2 id="ThreadLocal内存泄露分析"><a href="#ThreadLocal内存泄露分析" class="headerlink" title="ThreadLocal内存泄露分析"></a>ThreadLocal内存泄露分析</h2><h3 id="ThreadLocal实现原理"><a href="#ThreadLocal实现原理" class="headerlink" title="ThreadLocal实现原理"></a>ThreadLocal实现原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalMap</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;<br>        <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>        Object value;<br><br>        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>            <span class="hljs-built_in">super</span>(k);<br>            value = v;<br>        &#125;<br>    &#125;<br>    ...<br>   &#125;<br></code></pre></td></tr></table></figure><p>ThreadLocal的实现原理，每一个Thread维护一个ThreadLocalMap，key为使用<strong>弱引用</strong>的ThreadLocal实例，value为线程变量的副本。这些对象之间的引用关系如下：</p><p><img src="/markdown-img/ThreadLocal%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3.assets/picturea.png" alt="picturea"></p><blockquote><p>实心箭头表示强引用，空心箭头表示弱引用</p></blockquote><h3 id="ThreadLocal内存泄露原因"><a href="#ThreadLocal内存泄露原因" class="headerlink" title="ThreadLocal内存泄露原因"></a>ThreadLocal内存泄露原因</h3><p>从上图中可以看出，hreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal不存在外部<strong>强引用</strong>时，Key(ThreadLocal)势必会被GC回收，这样就会导致ThreadLocalMap中key为null， 而value还存在着强引用，只有thead线程退出以后,value的强引用链条才会断掉。</p><p>但如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：</p><blockquote><p>Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value</p></blockquote><p>永远无法回收，造成内存泄漏</p><h3 id="为什么使用弱引用而不是强引用"><a href="#为什么使用弱引用而不是强引用" class="headerlink" title="为什么使用弱引用而不是强引用"></a>为什么使用弱引用而不是强引用</h3><p><strong>key 使用强引用</strong></p><p>当threadLocalMap的key为强引用，回收ThreadLocal时，因为ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，导致Entry内存泄漏</p><p><strong>key 使用弱引用</strong></p><p>当ThreadLocalMap的key为弱引用回收ThreadLocal时，由于ThreadLocalMap持有ThreadLocal的弱引用，即使没有手动删除，ThreadLocal也会被回收。当key为null，在下一次ThreadLocalMap调用set()，get()，remove()方法的时候会被清除value值</p><h3 id="ThreadLocalMap的remove-源码分析"><a href="#ThreadLocalMap的remove-源码分析" class="headerlink" title="ThreadLocalMap的remove()源码分析"></a>ThreadLocalMap的remove()源码分析</h3><p>在这里只分析remove()方式，其他的方法可以查看源码进行分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> &#123;<br>    <span class="hljs-comment">//使用hash方式，计算当前ThreadLocal变量所在table数组位置</span><br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//再次循环判断是否在为ThreadLocal变量所在table数组位置</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i];<br>         e != <span class="hljs-literal">null</span>;<br>         e = tab[i = nextIndex(i, len)]) &#123;<br>        <span class="hljs-comment">// 考虑到可能的哈希冲突，一定要准确找到此key对应的entry</span><br>        <span class="hljs-keyword">if</span> (e.get() == key) &#123;<br>            <span class="hljs-comment">//调用WeakReference的clear方法清除对ThreadLocal的弱引用</span><br>            e.clear();<br>            <span class="hljs-comment">//清理key为null的元素</span><br>            expungeStaleEntry(i);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再看看清理key为null的元素expungeStaleEntry(i):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">expungeStaleEntry</span><span class="hljs-params">(<span class="hljs-type">int</span> staleSlot)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br><br>    <span class="hljs-comment">// 将entry的value赋值为null，这样方便GC时将真正value占用的内存给释放出来(不把value置为null也是可以的，但是可能影响GC效率)；将entry赋值为null，size减1，这样这个slot就又可以重新存放新的entry了</span><br>    tab[staleSlot].value = <span class="hljs-literal">null</span>;<br>    tab[staleSlot] = <span class="hljs-literal">null</span>;<br>    size--;<br><br>    Entry e;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-comment">//从staleSlot后一个index开始向后遍历，直到遇到为null的entry</span><br>    <span class="hljs-keyword">for</span> (i = nextIndex(staleSlot, len);<br>         (e = tab[i]) != <span class="hljs-literal">null</span>;<br>         i = nextIndex(i, len)) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br>        <span class="hljs-comment">//如果entry的key为null，则清除掉该entry</span><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;<br>            e.value = <span class="hljs-literal">null</span>;<br>            tab[i] = <span class="hljs-literal">null</span>;<br>            size--;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> k.threadLocalHashCode &amp; (len - <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//key的hash值不等于目前的index，说明该entry是因为有哈希冲突导致向后移动到当前index位置的</span><br>            <span class="hljs-keyword">if</span> (h != i) &#123;<br>                tab[i] = <span class="hljs-literal">null</span>;<br>                <span class="hljs-comment">//对该entry，重新进行hash并解决冲突</span><br>                <span class="hljs-keyword">while</span> (tab[h] != <span class="hljs-literal">null</span>)<br>                    h = nextIndex(h, len);<br>                tab[h] = e;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//返回经过整理后的，位于staleSlot位置后的第一个为null的entry的index值</span><br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>由于Thread中包含变量ThreadLocalMap，因此ThreadLocalMap与Thread的生命周期是一样长，如果都没有手动删除对应key，都会导致内存泄漏。</p><p>但是使用<strong>弱引用</strong>可以多一层保障：弱引用ThreadLocal不会内存泄漏，对应的value在下一次ThreadLocalMap调用set(),get(),remove()的时候会被清除。</p><p>因此，ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动调用对应key的remove方法就会导致内存泄漏，而不是因为弱引用</p><h3 id="ThreadLocal正确使用方法"><a href="#ThreadLocal正确使用方法" class="headerlink" title="ThreadLocal正确使用方法"></a>ThreadLocal正确使用方法</h3><ul><li>每次使用完ThreadLocal都调用它的remove()方法清除数据</li><li>将ThreadLocal变量定义成private static，这样就一直存在ThreadLocal的强引用，也就能保证任何时候都能通过ThreadLocal的弱引用访问到Entry的value值，进而清除掉（如果把ThreadLocal声明为某个类的实例变量（而不是静态变量），那么每创建一个该类的实例就会导致一个新的TSO实例被创建）</li></ul><h1 id="阿里的TTL"><a href="#阿里的TTL" class="headerlink" title="阿里的TTL"></a>阿里的TTL</h1><p><a href="https://github.com/alibaba/transmittable-thread-local">阿里Transmittable-thread-local(Github主页)</a></p><p><code>JDK</code>的<code>InheritableThreadLocal</code>类可以完成父线程到子线程的值传递。但对于使用线程池等会池化复用线程的执行组件的情况，线程由线程池创建好，并且线程是池化起来反复使用的；这时父子线程关系的<code>ThreadLocal</code>值传递已经没有意义，应用需要的实际上是把 <strong>任务提交给线程池时</strong>的<code>ThreadLocal</code>值传递到 <strong>任务执行时</strong></p><p><code>ThreadLocal</code>的需求场景即<code>TransmittableThreadLocal</code>的潜在需求场景，如果你的业务需要『在使用线程池等会池化复用线程的执行组件情况下传递<code>ThreadLocal</code>值』则是<code>TransmittableThreadLocal</code>目标场景</p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>布隆过滤器</title>
    <link href="/2025/06/28/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <url>/2025/06/28/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="1、什么是布隆过滤器"><a href="#1、什么是布隆过滤器" class="headerlink" title="1、什么是布隆过滤器"></a>1、什么是布隆过滤器</h2><p>布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都比一般的算法要好的多，缺点是有一定的误识别率和删除困难。  </p><p>上面这句介绍比较全面的描述了什么是布隆过滤器，如果还是不太好理解的话，就可以把布隆过滤器理解为一个set集合，我们可以通过add往里面添加元素，通过contains来判断是否包含某个元素。由于本文讲述布隆过滤器时会结合Redis来讲解，因此类比为Redis中的Set数据结构会比较好理解，而且Redis中的布隆过滤器使用的指令与Set集合非常类似（后续会讲到）。  </p><p>学习布隆过滤器之前有必要先聊下它的优缺点，因为好的东西我们才想要嘛！</p><p><strong>布隆过滤器的优点：</strong></p><ul><li>时间复杂度低，增加和查询元素的时间复杂为O(N)，（N为哈希函数的个数，通常情况比较小）</li><li>保密性强，布隆过滤器不存储元素本身</li><li>存储空间小，如果允许存在一定的误判，布隆过滤器是非常节省空间的（相比其他数据结构如Set集合）</li></ul><p><strong>布隆过滤器的缺点：</strong></p><ul><li>有点一定的误判率，但是可以通过调整参数来降低</li><li>无法获取元素本身</li><li>很难删除元素</li></ul><h2 id="2、布隆过滤器的使用场景"><a href="#2、布隆过滤器的使用场景" class="headerlink" title="2、布隆过滤器的使用场景"></a>2、布隆过滤器的使用场景</h2><p>布隆过滤器可以告诉我们 <strong>“某样东西一定不存在或者可能存在”，也就是说布隆过滤器说这个数不存在则一定不存，布隆过滤器说这个数存在可能不存在</strong>（误判，后续会讲），利用这个判断是否存在的特点可以做很多有趣的事情</p><ul><li><strong>解决Redis缓存穿透问题（面试重点）</strong></li><li>邮件过滤，使用布隆过滤器来做邮件黑名单过滤</li><li>对爬虫网址进行过滤，爬过的不再爬</li><li>解决新闻推荐过的不再推荐(类似抖音刷过的往下滑动不再刷到)</li><li>HBase\RocksDB\LevelDB等数据库内置布隆过滤器，用于判断数据是否存在，可以减少数据库的IO请求</li></ul><h2 id="3、布隆过滤器的原理"><a href="#3、布隆过滤器的原理" class="headerlink" title="3、布隆过滤器的原理"></a>3、布隆过滤器的原理</h2><h3 id="3-1-数据结构"><a href="#3-1-数据结构" class="headerlink" title="3.1 数据结构"></a>3.1 数据结构</h3><p>布隆过滤器它实际上是一个很长的二进制向量和一系列随机映射函数。以Redis中的布隆过滤器实现为例，Redis中的布隆过滤器底层是<strong>一个大型位数组（二进制数组）+多个无偏hash函数。</strong> </p><p><strong>一个大型位数组（二进制数组）</strong>：</p><p><img src="/markdown-img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.assets/e94e504adc5a75a2d7f562dc44166511.png" alt="位数组.png"></p><p><strong>多个无偏hash函数：</strong></p><p>无偏hash函数就是能把元素的hash值计算的比较均匀的hash函数，能使得计算后的元素下标比较均匀的映射到位数组中。</p><p>如下就是一个简单的布隆过滤器示意图，其中k1、k2代表增加的元素，a、b、c即为无偏hash函数，最下层则为二进制数组。</p><p><img src="/markdown-img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.assets/9ebde5c11ad69447314c216acf188fc8.png" alt="布隆过滤器.png"></p><h3 id="3-2-空间计算"><a href="#3-2-空间计算" class="headerlink" title="3.2 空间计算"></a>3.2 空间计算</h3><p>在布隆过滤器增加元素之前，首先需要初始化布隆过滤器的空间，也就是上面说的二进制数组，除此之外还需要计算无偏hash函数的个数。布隆过滤器提供了两个参数，分别是预计加入元素的大小n，运行的错误率f。布隆过滤器中有算法根据这两个参数会计算出二进制数组的大小l，以及无偏hash函数的个数k<br>它们之间的关系比较简单：</p><ul><li>错误率越低，位数组越长空间件占用较大</li><li>错误率越低，无偏hash函数越多，计算耗时较长</li></ul><p><strong>如下地址是一个免费的布隆过滤器在线计算的网址：</strong></p><blockquote><p><a href="https://krisives.github.io/bloom-calculator/">https://krisives.github.io/bloom-calculator/</a></p></blockquote><p><img src="/markdown-img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.assets/d9cce086a7b9da8afeeb752bdbe8f96e.png" alt="image.png"></p><h3 id="3-3-增加元素"><a href="#3-3-增加元素" class="headerlink" title="3.3 增加元素"></a>3.3 增加元素</h3><p>往布隆过滤器增加元素，添加的key需要根据k个无偏hash函数计算得到多个hash值，然后对数组长度进行取模得到数组下标的位置，然后将对应数组下标的位置的值置为1</p><ul><li>通过k个无偏hash函数计算得到k个hash值</li><li>依次取模数组长度，得到数组索引</li><li>将计算得到的数组索引下标位置数据修改为1</li></ul><p>例如，key &#x3D; Liziba，无偏hash函数的个数k&#x3D;3，分别为hash1、hash2、hash3。三个hash函数计算后得到三个数组下标值，并将其值修改为1，如图所示：</p><p><img src="/markdown-img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.assets/a3e7d217ecb825e94bdc577a467eb29d.png" alt="增加元素.png"></p><h3 id="3-4-查询元素"><a href="#3-4-查询元素" class="headerlink" title="3.4 查询元素"></a>3.4 查询元素</h3><p>布隆过滤器最大的用处就在于判断某样东西一定不存在或者可能存在，而这个就是查询元素的结果。其查询元素的过程如下：</p><ul><li>通过k个无偏hash函数计算得到k个hash值</li><li>依次取模数组长度，得到数组索引</li><li>判断索引处的值是否全部为1，如果全部为1则存在（这种存在可能是误判），如果存在一个0则必定不存在</li></ul><p><strong>关于误判</strong>，其实非常好理解，hash函数再怎么好，也无法完全避免hash冲突，也就是说可能会存在多个元素计算的hash值是相同的，那么它们取模数组长度后的到的数组索引也是相同的，这就是误判的原因。例如李子捌和李子柒的hash值取模后得到的数组索引都是1，但其实这里只有李子捌，如果此时判断李子柒在不在这里，误判就出现啦！因此布隆过滤器最大的缺点误判只要知道其判断元素是否存在的原理就很容易明白了！</p><h3 id="3-5-修改元素"><a href="#3-5-修改元素" class="headerlink" title="3.5 修改元素"></a>3.5 修改元素</h3><p>无  </p><h3 id="3-6-删除元素"><a href="#3-6-删除元素" class="headerlink" title="3.6 删除元素"></a>3.6 删除元素</h3><p>布隆过滤器对元素的删除不太支持，目前有一些变形的特定布隆过滤器支持元素的删除！关于为什么对删除不太支持，其实也非常好理解，hash冲突必然存在，删除肯定是很苦难的！  </p><h2 id="4、Redis集成布隆过滤器"><a href="#4、Redis集成布隆过滤器" class="headerlink" title="4、Redis集成布隆过滤器"></a>4、Redis集成布隆过滤器</h2><h3 id="4-1-版本要求"><a href="#4-1-版本要求" class="headerlink" title="4.1 版本要求"></a>4.1 版本要求</h3><ul><li><strong>推荐版本6.x，最低4.x版本，可以通过如下命令查看版本：</strong></li></ul><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbscript">redis-<span class="hljs-built_in">server</span> -v<br></code></pre></td></tr></table></figure><p><img src="/markdown-img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.assets/6e773444634fc627a5aaab6263fbf848.png" alt="image.png"></p><ul><li><strong>插件安装，网上大部分推荐v1.1.1，文章写的时候v2.2.6已经是release版本了，用户自己选择，地址全在下面(2.2.6官网介绍说是1.0版本的维护版本，如果不想使用新的功能，无需升级！)</strong></li></ul><p><img src="/markdown-img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.assets/f57516a57df20da8b8aa92145e72ce62.png" alt="image.png"></p><p><strong>v1.1.1</strong></p><blockquote><p><a href="https://github.com/RedisLabsModules/rebloom/archive/v1.1.1.tar.gz">https://github.com/RedisLabsModules/rebloom/archive/v1.1.1.tar.gz</a></p></blockquote><p><strong>v2.2.6</strong></p><blockquote><p><a href="https://github.com/RedisLabsModules/rebloom/archive/v2.2.6.tar.gz">https://github.com/RedisLabsModules/rebloom/archive/v2.2.6.tar.gz</a></p></blockquote><h3 id="4-2-安装-编译"><a href="#4-2-安装-编译" class="headerlink" title="4.2 安装&amp;编译"></a>4.2 安装&amp;编译</h3><p>以下安装全部在指定目录下完成，可以选择一个合适的统一目录进行软件安装和管理</p><p><strong>4.2.1 下载插件压缩包</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cobol">wget https://github.com/RedisLabsModules/rebloom/archive/v2.2.6.tar.gz<br></code></pre></td></tr></table></figure><p><strong>4.2.2 解压</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cobol">tar -zxvf v2.2.6.tar.gz<br></code></pre></td></tr></table></figure><p><strong>4.2.3 编译插件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cobol">cd RedisBloom-2.2.6/make<br></code></pre></td></tr></table></figure><p><img src="/markdown-img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.assets/f11054f4f831b629a46b3d4e727b4c6d.png" alt="image.png"></p><p>编译成功后看到redisbloom.so文件即可  </p><h3 id="4-3-Redis集成"><a href="#4-3-Redis集成" class="headerlink" title="4.3 Redis集成"></a>4.3 Redis集成</h3><p><strong>4.3.1 Redis配置文件修改</strong></p><ul><li>在<strong>redis.conf配置文件</strong>中加入如RedisBloom的redisbloom.so文件的地址</li><li>如果是<strong>集群</strong>则每个配置文件中都需要加入redisbloom.so文件的地址</li><li>添加完成后需要<strong>重启redis</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">loadmodule /usr/local/soft/RedisBloom-<span class="hljs-number">2.2</span><span class="hljs-number">.6</span>/redisbloom.so<br></code></pre></td></tr></table></figure><p><strong>redis.conf配置文件中预置了loadmodule的配置项，我们可以直接在这里修改，后续修改会更加方便。</strong></p><p><img src="/markdown-img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.assets/f69019f455492424ccb0fb7082ceb677.png" alt="image.png"></p><p>保存退出后一定要记得重启Redis！</p><p><strong>4.3.2 测试是否成功</strong></p><p>Redis集成布隆过滤器的主要指令如下：</p><ul><li>bf.add 添加一个元素</li><li>bf.exists 判断一个元素是否存在</li><li>bf.madd 添加多个元素</li><li>bf.mexists 判断多个元素是否存在</li></ul><p>连接客户端进行测试，如果指令有效则证明集成成功</p><p><img src="/markdown-img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.assets/93ff2593a25df2d2e0df237eb54ee2ab.png" alt="image.png"></p><p>如果出现如下情况(error) ERR unknown command ，可以通过如下方法检查：</p><ul><li>SHUTDOWN Redis实例，再重启实例，再次测试</li><li>检查配置文件是否配置redisbloom.so文件地址正确</li><li>检查Redis的版本是否过低</li></ul><p><img src="/markdown-img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.assets/0e82b96e2fe2f9bc869f10a0709a8677.png" alt="image.png"></p><h2 id="5、Redis中布隆过滤器指令使用"><a href="#5、Redis中布隆过滤器指令使用" class="headerlink" title="5、Redis中布隆过滤器指令使用"></a>5、Redis中布隆过滤器指令使用</h2><h3 id="5-1-bf-add"><a href="#5-1-bf-add" class="headerlink" title="5.1 bf.add"></a>5.1 bf.add</h3><p>bf.add表示添加单个元素，添加成功返回1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; bf.add name <span class="hljs-title function_">liziba</span><br><span class="hljs-params">(integer)</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><img src="/markdown-img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.assets/3c51b61f0d3eb3cb36e5bd0dd00c1b97.png" alt="image.png"></p><h3 id="5-2-bf-madd"><a href="#5-2-bf-madd" class="headerlink" title="5.2 bf.madd"></a>5.2 bf.madd</h3><p>bf.madd表示添加多个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; bf.madd name liziqi lizijiu lizishi<br><span class="hljs-number">1</span>) (integer) <span class="hljs-number">1</span><br><span class="hljs-number">2</span>) (integer) <span class="hljs-number">1</span><br><span class="hljs-number">3</span>) (integer) <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><img src="/markdown-img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.assets/c0979853a63483b4b96a64013e24c216.png" alt="image.png"></p><h3 id="5-3-bf-exists"><a href="#5-3-bf-exists" class="headerlink" title="5.3 bf.exists"></a>5.3 bf.exists</h3><p>bf.exists表示判断元素是否存在，存在则返回1，不存在返回0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cobol">127.0.0.1:6379&gt; bf.mexists name liziba1) (integer) 1<br></code></pre></td></tr></table></figure><p><img src="/markdown-img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.assets/4f483f31376dc8f1d60445e1be00c5d6.png" alt="image.png"></p><h3 id="5-3-bf-mexists"><a href="#5-3-bf-mexists" class="headerlink" title="5.3 bf.mexists"></a>5.3 bf.mexists</h3><p>bf.mexists表示判断多个元素是否存在，存在的返回1，不存在的返回0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; bf.mexists name liziba<br><span class="hljs-number">1</span>) (integer) <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><img src="/markdown-img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.assets/d5c0a83cd3b23fdb566537a5baeebaa1.png" alt="image.png"></p><h2 id="6、Java本地内存使用布隆过滤器"><a href="#6、Java本地内存使用布隆过滤器" class="headerlink" title="6、Java本地内存使用布隆过滤器"></a>6、Java本地内存使用布隆过滤器</h2><p>使用布隆过滤器的方式有很多，还有很多大佬自己手写的，我这里使用的是谷歌guava包中实现的布隆过滤器，这种方式的布隆过滤器是在本地内存中实现。</p><h3 id="6-1-引入pom依赖"><a href="#6-1-引入pom依赖" class="headerlink" title="6.1 引入pom依赖"></a>6.1 引入pom依赖</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;  <br>      &lt;groupId&gt;com.google.guava&lt;/groupId&gt;    &lt;artifactId&gt;guava&lt;/artifactId&gt;  <br>      &lt;version&gt;<span class="hljs-number">29.0</span>-jre&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h3 id="6-2-编写测试代码"><a href="#6-2-编写测试代码" class="headerlink" title="6.2 编写测试代码"></a>6.2 编写测试代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lizba.bf;<br> <br><span class="hljs-keyword">import</span> com.google.common.hash.BloomFilter;<br><span class="hljs-keyword">import</span> com.google.common.hash.Funnels;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> *        布隆过滤器测试代码</span><br><span class="hljs-comment"> * &lt;/p&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Liziba</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2021/8/29 14:51</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BloomFilterTest</span> &#123;<br> <br>    <span class="hljs-comment">/** 预计插入的数据 */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Integer</span> <span class="hljs-variable">expectedInsertions</span> <span class="hljs-operator">=</span> <span class="hljs-number">10000000</span>;<br>    <span class="hljs-comment">/** 误判率 */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Double</span> <span class="hljs-variable">fpp</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.01</span>;<br>    <span class="hljs-comment">/** 布隆过滤器 */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> BloomFilter&lt;Integer&gt; bloomFilter = BloomFilter.create(Funnels.integerFunnel(), expectedInsertions, fpp);<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 插入 1千万数据</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; expectedInsertions; i++) &#123;<br>            bloomFilter.put(i);<br>        &#125;<br> <br>        <span class="hljs-comment">// 用1千万数据测试误判率</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> expectedInsertions; i &lt; expectedInsertions *<span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (bloomFilter.mightContain(i)) &#123;<br>                count++;<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;一共误判了：&quot;</span> + count);<br> <br>    &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-3-测试结果"><a href="#6-3-测试结果" class="headerlink" title="6.3 测试结果"></a>6.3 测试结果</h3><p>误判了100075次，大概是expectedInsertions（1千万）的0.01，这与我们设置的 <em>fpp</em> &#x3D; 0.01非常接近</p><p><img src="/markdown-img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.assets/dfac339413b1b414a07dd6841f25f624.png" alt="image.png"></p><h3 id="6-4-参数说明"><a href="#6-4-参数说明" class="headerlink" title="6.4 参数说明"></a>6.4 参数说明</h3><p>在guava包中的BloomFilter源码中，构造一个BloomFilter对象有四个参数：</p><ul><li><strong>Funnel funnel：</strong>数据类型，由Funnels类指定即可</li><li><strong>long expectedInsertions：</strong>预期插入的值的数量</li><li><strong>fpp：</strong>错误率</li><li><strong>BloomFilter.Strategy：</strong>hash算法</li></ul><h3 id="6-5-fpp-expectedInsertions"><a href="#6-5-fpp-expectedInsertions" class="headerlink" title="6.5 fpp&amp;expectedInsertions"></a>6.5 fpp&amp;expectedInsertions</h3><ul><li>当expectedInsertions&#x3D;10000000&amp;&amp;fpp&#x3D;0.01时，位数组的大小numBits&#x3D;95850583，hash函数的个数numHashFunctions&#x3D;7</li></ul><p><img src="/markdown-img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.assets/d19ea61540f341245d0a43f6997c94a3.png" alt="image.png"></p><ul><li>当expectedInsertions&#x3D;10000000&amp;&amp;fpp&#x3D;0.03时，位数组的大小numBits&#x3D;72984408，hash函数的个数numHashFunctions&#x3D;5</li></ul><p><img src="/markdown-img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.assets/2452aa80a08537832253d17c9750398d.png" alt="image.png"></p><ul><li>当expectedInsertions&#x3D;100000&amp;&amp;fpp&#x3D;0.03时，位数组的大小numBits&#x3D;729844，hash函数的个数numHashFunctions&#x3D;5</li></ul><p><img src="/markdown-img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.assets/e23d57abceb6ff575fdb12b819502f1f.png" alt="image.png"></p><p>综上三次测试可以得出如下结论：</p><ul><li>当预计插入的值的数量不变时，偏差值fpp越小，位数组越大，hash函数的个数越多</li><li>当偏差值不变时，预计插入的中的数量越大，位数组越大，hash函数并没有变化（注意这个结论只是在guava实现的布隆过滤器中的算法符合，并不是说所有的算法都是这个结论，我做了多次测试，确实numHashFunctions在fpp相同时，是不变的！）</li></ul><h2 id="7、Java集成Redis使用布隆过滤器"><a href="#7、Java集成Redis使用布隆过滤器" class="headerlink" title="7、Java集成Redis使用布隆过滤器"></a>7、Java集成Redis使用布隆过滤器</h2><p>Redis经常会被问道缓存击穿问题，比较优秀的解决办法是使用布隆过滤器，也有使用空对象解决的，但是最好的办法肯定是布隆过滤器，我们可以通过布隆过滤器来判断元素是否存在，避免缓存和数据库都不存在的数据进行查询访问！在如下的代码中只要通过bloomFilter.contains(xxx)即可，我这里演示的还是误判率！</p><h3 id="7-1-引入pom依赖"><a href="#7-1-引入pom依赖" class="headerlink" title="7.1 引入pom依赖"></a>7.1 引入pom依赖</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>  &lt;groupId&gt;org.redisson&lt;/groupId&gt;<br>  &lt;artifactId&gt;redisson-spring-boot-starter&lt;/artifactId&gt;<br>  &lt;version&gt;<span class="hljs-number">3.16</span><span class="hljs-number">.0</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h3 id="7-2-编写测试代码"><a href="#7-2-编写测试代码" class="headerlink" title="7.2 编写测试代码"></a>7.2 编写测试代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lizba.bf;<br> <br><span class="hljs-keyword">import</span> org.redisson.Redisson;<br><span class="hljs-keyword">import</span> org.redisson.api.RBloomFilter;<br><span class="hljs-keyword">import</span> org.redisson.api.RedissonClient;<br><span class="hljs-keyword">import</span> org.redisson.config.Config;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> *      Java集成Redis使用布隆过滤器防止缓存穿透方案</span><br><span class="hljs-comment"> * &lt;/p&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Liziba</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2021/8/29 16:13</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisBloomFilterTest</span> &#123;<br> <br>    <span class="hljs-comment">/** 预计插入的数据 */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Integer</span> <span class="hljs-variable">expectedInsertions</span> <span class="hljs-operator">=</span> <span class="hljs-number">10000</span>;<br>    <span class="hljs-comment">/** 误判率 */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Double</span> <span class="hljs-variable">fpp</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.01</span>;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// Redis连接配置，无密码</span><br>        <span class="hljs-type">Config</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Config</span>();<br>        config.useSingleServer().setAddress(<span class="hljs-string">&quot;redis://192.168.211.108:6379&quot;</span>);<br>        <span class="hljs-comment">// config.useSingleServer().setPassword(&quot;123456&quot;);</span><br> <br>        <span class="hljs-comment">// 初始化布隆过滤器</span><br>        <span class="hljs-type">RedissonClient</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> Redisson.create(config);<br>        RBloomFilter&lt;Object&gt; bloomFilter = client.getBloomFilter(<span class="hljs-string">&quot;user&quot;</span>);<br>        bloomFilter.tryInit(expectedInsertions, fpp);<br> <br>        <span class="hljs-comment">// 布隆过滤器增加元素</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; expectedInsertions; i++) &#123;<br>            bloomFilter.add(i);<br>        &#125;<br> <br>        <span class="hljs-comment">// 统计元素</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> expectedInsertions; i &lt; expectedInsertions*<span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (bloomFilter.contains(i)) &#123;<br>                count++;<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;误判次数&quot;</span> + count);<br> <br>    &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-3-测试结果"><a href="#7-3-测试结果" class="headerlink" title="7.3 测试结果"></a>7.3 测试结果</h3><p><img src="/markdown-img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.assets/8ef4dd0de55a1da3d9d66298ddbd9d3f.png" alt="image.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/06/27/hello-world/"/>
    <url>/2025/06/27/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
