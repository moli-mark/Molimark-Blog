<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>一小时，搭建属于自己的个人博客</title>
    <link href="/2025/06/29/%E4%B8%80%E5%B0%8F%E6%97%B6%EF%BC%8C%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2025/06/29/%E4%B8%80%E5%B0%8F%E6%97%B6%EF%BC%8C%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>操作环境：<br>1.mac电脑</p><p>前置条件：<br>1.安装Node.js<br>2.安装Git</p><p>正式建站：<br>1.执行npm install -g hexo-cli安装hexo<br>2.执行hexo init MyBlog创建MyBlog文件夹<br>3.进入刚刚创建的MyBlog文件夹执行npm install命令<br>第三步执行完后，MyBlog文件夹中内容如下所示：<br>├── _config.yml<br>├── package.json<br>├── scaffolds<br>├── source<br>|   ├── _drafts<br>|   └── _posts<br>└── themes<br>4.执行npm install –save hexo-theme-fluid命令安装fluid主题<br>5.在MyBlog文件夹中创建_config.fluid.yml文件，文件内容从<a href="https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml%E4%B8%AD%E5%A4%8D%E5%88%B6">https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml中复制</a><br>6.在Github新建名称为{username}.github.io仓库，并设置为Public。这里的username为Github用户名，例如我的就是moli-mark.github.io<br>7.在Github个人设置Settings-&gt;Developer Settings-&gt;Personal access tokens-&gt;Tokens(classic)中创建密钥<br>8.编辑_config.yml文件,{密钥}替换成第七步中创建的密钥,{username}替换成你Github的用户名<br>theme: fluid<br>language: zh-CN<br>deploy:<br>  type: git<br>  repo: https:&#x2F;&#x2F;{密钥}@github.com&#x2F;{username}&#x2F;{username}.github.io<br>  branch: main<br>9.在MyBlog文件夹中执行命令hexo deploy<br>10.访问{username}.github.io，就可以看到自己的网站了！</p><p>更多网站参数配置可参考<a href="https://fluid-dev.github.io/hexo-fluid-docs/guide/#%E5%85%B3%E4%BA%8E%E6%8C%87%E5%8D%97%EF%BC%8C%E6%A0%B9%E6%8D%AE%E4%B8%AA%E4%BA%BA%E9%9C%80%E8%A6%81%E5%8F%8A%E5%96%9C%E5%A5%BD%E8%B0%83%E6%95%B4">https://fluid-dev.github.io/hexo-fluid-docs/guide/#%E5%85%B3%E4%BA%8E%E6%8C%87%E5%8D%97，根据个人需要及喜好调整</a></p><p>欢迎访问我的个人博客，互相交流：<a href="https://moli-mark.github.io/">https://moli-mark.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>独立开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDK17营销初体验——亚毫秒停顿ZGC落地实践</title>
    <link href="/2025/06/29/JDK17%E8%90%A5%E9%94%80%E5%88%9D%E4%BD%93%E9%AA%8C%E2%80%94%E2%80%94%E4%BA%9A%E6%AF%AB%E7%A7%92%E5%81%9C%E9%A1%BFZGC%E8%90%BD%E5%9C%B0%E5%AE%9E%E8%B7%B5/"/>
    <url>/2025/06/29/JDK17%E8%90%A5%E9%94%80%E5%88%9D%E4%BD%93%E9%AA%8C%E2%80%94%E2%80%94%E4%BA%9A%E6%AF%AB%E7%A7%92%E5%81%9C%E9%A1%BFZGC%E8%90%BD%E5%9C%B0%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p>距离 JDK 8 发布已经过去了 9 年，那么这 9 年的时间，JDK 做了哪些升级？是否有新的重大特性值得尝试？能否解决一些现在令人苦恼的问题？带着这份疑问进行了 JDK 版本的调研与升级踩坑记录，希望本文能够帮到大家  </p><p><strong>前言</strong></p><p>自 2014 年发布以来， JDK 8 一直都是相当热门的 JDK 版本。其原因就是对底层数据结构、JVM 性能以及开发体验做了重大升级，得到了开发人员的认可。但距离 JDK 8 发布已经过去了 9 年，那么这 9 年的时间，JDK 做了哪些升级？是否有新的重大特性值得尝试？能否解决一些现在令人苦恼的问题？带着这份疑问进行了 JDK 版本的调研与尝试</p><h1 id="新特性一览"><a href="#新特性一览" class="headerlink" title="新特性一览"></a><strong>新特性一览</strong></h1><p>理解，首先 MCube 会依据模板缓存状态判断是否需要网络获取最新模板，当获取到模板后进行模板加载，加载阶段会将产物转换为视图树的结构，转换完成后将通过表达式引擎解析表达式并取得正确的值，通过事件解析引擎解析用户自定义事件并完成事件的绑定，完成解析赋值以及事件绑定后进行视图的渲染，最终将目标页面展示到屏幕。</p><p>现如今的 JDK 发布节奏变快，每次新出一个版本，不禁会令人感叹：“我还在用 JDK 8，现在都 JDK 9、10、11 …… 21 了？”然后就会瞅瞅又多了哪些新特性。有一些新特性很香，但考虑一番还是决定放弃升级。主要原因除了新增特性对用户来说改变不大以外，最重要的就是 JDK 9 带来的模块化（JEP 200），导致升级十分困难。</p><p>模块化的本意是将 JDK 划分为一组模块，这些模块可以在编译时、构建时和运行时组合成各种配置，主要目标是使实现更容易扩展到小型设备，提高安全性和可维护性，并提高应用程序性能。但付出的代价非常大，最直观的影响就是，一些 JDK 内部类不能访问了。</p><p>但是除此之外，并没有太多阻塞升级的问题，后续版本都是一些很香的特性：</p><ul><li><p>G1 （JEP 248、JEP 307、JEP 344、JEP 345、JEP 346），提供一个支持指定暂停时间、NUMA 感知内存分配的高性能垃圾回收器</p></li><li><p>ZGC （JEP 333、JEP 376、JEP 377），一个支持 NUMA，暂停时间不应超过 1ms 的垃圾回收器</p></li><li><p>并发 API 更新（JEP 266），提供 publish-subscribe 框架，支持响应式流发布 - 订阅框架的接口，以及 CompletableFuture 的进一步完善</p></li><li><p>集合工厂方法（JEP 269），类似 Guava，支持快速创建有初始元素的集合</p></li><li><p>新版 HTTP 客户端（JEP 321），一个现代化、支持异步、WebSocket、响应式流的 JDK 内置 API</p></li><li><p>空指针 NPE 直接给出异常方法位置（JEP 358），以前只给代码行数，不告诉哪个方法，一行多个方法的写法一但出现空指针，全靠程序员上下文分析推理</p></li><li><p>instanceof 的模式匹配（JEP 394），判断类型后再也不用强转了</p></li><li><p>数据记录类（JEP 395），一个标准的值聚合类，帮助程序员专注于对不可变数据进行建模，实现数据驱动</p></li><li><p>Switch 表达式语法改进（JEP 361），改变 Switch 又臭又长，易于出错的现状</p></li><li><p>文本块（JEP 378），支持二维文本块，而不是像现在一样通过 + 号自行拼接</p></li><li><p>密封类（JEP 409），提供一种限制进行扩展的语法，超类应该可以被广泛访问（因为它代表了用户的重要抽象），但不能广泛扩展（因为它的子类应该仅限于作者已知的子类）</p></li><li><p>以及一些未提到的底层数据结构优化，JVM 性能提升……</p></li></ul><p>这么多的优点，恰好能解决当前遇到的一些问题，因此决定进行 JDK 升级。</p><p><strong>03</strong> </p><h1 id="升级"><a href="#升级" class="headerlink" title="升级"></a><strong>升级</strong></h1><p>理解，首先 MCube 会依据模板缓存状态判断是否需要网络获取最新模板，当获取到模板后进行模板加载，加载阶段会将产物转换为视图树的结构，转换完成后将通过表达式引擎解析表达式并取得正确的值，通过事件解析引擎解析用户自定义事件并完成事件的绑定，完成解析赋值以及事件绑定后进行视图的渲染，最终将目标页面展示到屏幕。</p><p><strong>3.1  升级应用评估</strong></p><p>首先自然是要考虑要将哪些应用进行升级。根据以下条件进行应用筛选：</p><ol><li><p>第一，也是最重要的一点，此系统可以通过升级，解决现有问题与瓶颈</p></li><li><p>第二，有完备的机制能够进行快速回归与验证，如完备的单元测试，自动化测试覆盖能力，便捷的生产压测能力等，底层的升级一定要做好完备的验证</p></li><li><p>第三，技术债务一定要少，不至于在升级过程中遇到一些必须解决的技术债，给升级增加难度</p></li><li><p>第四，负责升级的人对这个系统都很了解，除核心业务逻辑外，还能够了解引入了哪些中间件与依赖，使用了中间件的哪些功能，中间件升级后，大量不兼容的改动是否对现有系统造成影响</p></li></ol><p>最终选取了一个结算页、收银台展示无券支付营销的应用进行升级。此应用特点如下：</p><ul><li><p>作为核心链路的应用之一，接口响应时间要求很高，GC 是其耗时抖动的瓶颈之一</p></li><li><p>业务正在进行快速迭代发展，随着降本增效策略的落地，营销策略进一步精细化，营销种类、数量、范围进一步增加，给系统性能带来更大的挑战</p></li><li><p>日常流量不低，整点存在突发流量，并且需要承接大促流量</p></li><li><p>核心链路覆盖了单元测试，测试环境具备自动化回归能力，预发、生产支持常态化压测与生产流量回放</p></li><li><p>非 Web 应用，仅使用各个中间件的基础功能，升级出现不兼容的问题小</p></li><li><p>维护了 3 年，经历过多次重构，历史问题较少，几乎没有技术债务</p></li></ul><p>针对以上特点，此应用很适合进行 JDK 17 升级。此应用基于 JDK 8，SpringBoot 2.0.8，除常见外部基础组件外，还使用以下公司内部中间件：UMP、SGM、DUCC、CDS、JMQ、JSF、R2M。</p><p><strong>3.2  升级效果</strong></p><p>可以先看下升级后压测的效果：</p><p>纯计算代码不再受 GC 影响</p><p><img src="/markdown-img/JDK17%E8%90%A5%E9%94%80%E5%88%9D%E4%BD%93%E9%AA%8C%E2%80%94%E2%80%94%E4%BA%9A%E6%AF%AB%E7%A7%92%E5%81%9C%E9%A1%BFZGC%E8%90%BD%E5%9C%B0%E5%AE%9E%E8%B7%B5.assets/640-20231216215259771.png" alt="图片">图1.纯计算代码不再受 GC 影响</p><p>升级前</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/RQv8vncPm1Uho1szsw2HxpQczHKibCc9VJV9viaFjtxFE6aYicQWBPPh8tGqlQFWOI7BicORANPBAlflrHYlgas5JA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">图2.升级前示意</p><p>升级后</p><p><img src="/markdown-img/JDK17%E8%90%A5%E9%94%80%E5%88%9D%E4%BD%93%E9%AA%8C%E2%80%94%E2%80%94%E4%BA%9A%E6%AF%AB%E7%A7%92%E5%81%9C%E9%A1%BFZGC%E8%90%BD%E5%9C%B0%E5%AE%9E%E8%B7%B5.assets/640-20231216215259774.png" alt="图片">图3.升级后示意</p><table><thead><tr><th>版本</th><th>吞吐量</th><th>平均耗时</th><th>最大耗时</th></tr></thead><tbody><tr><td>JDK 8 G1</td><td>99.966%</td><td>35.7ms</td><td>120ms</td></tr><tr><td>JDK 17 ZGC</td><td>99.999%</td><td>0.0254ms</td><td>0.106ms</td></tr></tbody></table><p>升级后吞吐量几乎不受影响（甚至提升 0.01%），GC 平均耗时下降 1405 倍，GC 最大耗时下降 1132 倍。</p><p><strong>3.3  升级步骤</strong></p><h3 id="升级-JDK-编译版本"><a href="#升级-JDK-编译版本" class="headerlink" title="升级 JDK 编译版本"></a><strong>升级 JDK 编译版本</strong></h3><p>首先自然是修改 maven 中指定的 JDK 版本，可以先升级到 JDK 11，同时修改 maven 编译插件。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;java.<span class="hljs-built_in">version</span>&gt;<span class="hljs-number">11</span>&lt;/java.<span class="hljs-built_in">version</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="引入缺少的依赖"><a href="#引入缺少的依赖" class="headerlink" title="引入缺少的依赖"></a><strong>引入缺少的依赖</strong></h3><p>然后就可以进行本地编译了，此时会暴露一些很简单的问题，比如找不到包、类等等。原因就是 JDK 11 移除了 Java EE and CORBA 的模块，需要手动引入。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- JAVAX --&gt;</span>  <br></code></pre></td></tr></table></figure><h3 id="升级外部中间件"><a href="#升级外部中间件" class="headerlink" title="升级外部中间件"></a><strong>升级外部中间件</strong></h3><p>解决了编译找不到类的问题，接下来就该升级依赖的外部中间件了。对于应用来说，也就是升级 SpringBoot 的版本。支持 JDK 17 的版本是 Spring 5.3，对应 SpringBoot 2.5。</p><p>在这里建议升级至 SpringBoot 2.7，从 2.5 升级至 2.7 几乎没有需要改动的地方，同时高版本的 SprngBoot 所约定的依赖，对 JDK 17 的支持也更好。</p><p>建议进行大版本逐个升级，比如从 2.0 升级至 2.1。每升一个版本，就要仔细观察依赖版本的变化，掌握每个依赖升级的情况。SpringBoot 的升级其实意味着把所有开源组件约定版本进行大版本升级，接口弃用，破坏性兼容更新较多，需要一一鉴别。</p><p>下面以升级 Spring Boot 2.1 为例，说明升级的步骤：</p><p><img src="/markdown-img/JDK17%E8%90%A5%E9%94%80%E5%88%9D%E4%BD%93%E9%AA%8C%E2%80%94%E2%80%94%E4%BA%9A%E6%AF%AB%E7%A7%92%E5%81%9C%E9%A1%BFZGC%E8%90%BD%E5%9C%B0%E5%AE%9E%E8%B7%B5.assets/640-20231216215259844.png" alt="图片"></p><p>至此，Spring Boot 2.1 升级完毕。接下来分析一次依赖树变化，和升级前的依赖树进行比较，查看依赖变化范围是否全部已知可控。完成后进行 Spring Boot 2.2 的升级。</p><p>以下为需要注意的升级事项，仅供参考：</p><ul><li><p>可以先升级到 JDK 11，一边启动一边验证。但不要在 JDK 11 使用 ZGC，ZGC 的堆预留与可用堆的比例太大，有时会导致 OOM</p></li><li><p>代码中存在同 Bean，启动时 Springboot 2.0 会自动进行覆盖，高版本开启覆盖，需要指定 <code>spring.main.allow-bean-definition-overriding</code> 为 <code>true</code></p></li><li><p>Spring Boot 2.2 默认的单元测试 Junit 升级至 5，Junit 4 的单元测试建议进行升级，改动不大</p></li><li><p>Spring Boot 2.4 不再支持 Junit 4 的单元测试，如果需要可以手动引入 Vintage 引擎</p></li><li><p>Spring Boot 2.4 配置文件处理逻辑变更，注意阅读更新日志</p></li><li><p>Spring Boot 2.6 默认禁用 Bean 循环依赖，可以通过将 <code>spring.main.allow-circular-references</code> 设置为 <code>true</code> 开启</p></li><li><p>Spring Boot 2.7 自动配置注册文件变更，<code>spring.factories</code> 中的内容需要移动至 <code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code> 文件下</p></li><li><p><code>spring-boot-properties-migrator</code> 可以识别弃用的属性，可以考虑使用</p></li><li><p>Spring Framework 5.2 需要 Jackson 2.9.7+，注意阅读更新日志</p></li><li><p>Spring Framework 5.2 注解检索算法重构，所有自定义注释都必须使用 <code>@Retention(RetentionPolicy.RUNTIME)</code> 进行注释，以便 Spring 能够找到它们</p></li><li><p>Spring Framework 5.3 修改了很多东西，但都与应用无关，请关注更新日志</p></li><li><p>ASM 仅单元测试 Mock 在使用，无需特殊关注，做好 JUnit 升级兼容即可</p></li><li><p>CGLIB 大版本升级以兼容字节码版本为主，关注好变更日志即可</p></li><li><p>Lombok 即使是小版本升级，也会有破坏性更新，需要仔细阅读每个版本的更新日志，建议少用 Lombok</p></li><li><p>Hibernate 没有太大的破坏性更新，关注好变更日志即可</p></li><li><p>JUnit 升级主要关注大版本变更，如 4 升 5，小版本没有特别大的破坏性更新，并且是单元测试使用的依赖，可以放心升级或者不升级</p></li><li><p>Jackson 2.11，对 <code>java.util.Date</code> 和 <code>java.util.Calendar</code> 默认格式进行了更改，注意查看更新日志进行兼容</p></li><li><p>注意字节码增强相关依赖的升级</p></li><li><p>注意本地缓存升级</p></li><li><p>注意 Netty 升级，关注更新日志</p></li></ul><h3 id="升级内部中间件"><a href="#升级内部中间件" class="headerlink" title="升级内部中间件"></a><strong>升级内部中间件</strong></h3><p>内部中间件升级较为简单，主要是关注 JMQ、JSF 版本。其中 JSF 依赖的 Netty 和 Javassist 等都需要升级，Netty 版本较低会有内存泄漏问题。</p><h3 id="使用的依赖版本"><a href="#使用的依赖版本" class="headerlink" title="使用的依赖版本"></a><strong>使用的依赖版本</strong></h3><p>给大家参考下升级后的依赖版本</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;properties&gt;</span>  <br></code></pre></td></tr></table></figure><h3 id="JVM-启动参数升级"><a href="#JVM-启动参数升级" class="headerlink" title="JVM 启动参数升级"></a><strong>JVM 启动参数升级</strong></h3><p>远程 DEBUG 参数有所变化：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">JAVA_DEBUG_OPTS</span>=<span class="hljs-string">&quot; -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:8000 &quot;</span><br></code></pre></td></tr></table></figure><p>打印 GC 日志参数的变化，在预发环境开启了日志进行观察：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">JAVA_GC_LOG_OPTS</span>=<span class="hljs-string">&quot; -Xlog:gc*:file=/export/logs/gc.log:time,tid,tags:filecount=10:filesize=10m &quot;</span><br></code></pre></td></tr></table></figure><p>使用了 ZGC 的部分 JVM 参数：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">JAVA_MEM_OPTS</span>=<span class="hljs-string">&quot; -server -Xmx12g -Xms12g -XX:MaxMetaspaceSize=256m -XX:MetaspaceSize=256m -XX:MaxDirectMemorySize=2048m -XX:+UseZGC -XX:ZAllocationSpikeTolerance=3 -XX:ParallelGCThreads=8 -XX:CICompilerCount=3 -XX:-RestrictContended -XX:+AlwaysPreTouch -XX:+ExplicitGCInvokesConcurrent -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/export/logs &quot;</span><br></code></pre></td></tr></table></figure><p>内部依赖需要访问 JDK 模块，如 UMP、JSF、虫洞、MyBatis、DUCC、R2M、SGM：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> <span class="hljs-string">[[ &quot;$JAVA_VERSION&quot; -ge 11 ]]</span>; <span class="hljs-keyword">then</span>  <br></code></pre></td></tr></table></figure><p>启动后完整的启动参数如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">-javaagent:/export/package/sgm-probe-java/sgm-probe-5.9.5-product/sgm-agent-5.9.5.jar -Dsgm.server.<span class="hljs-attribute">address</span>=http://sgm.jdfin.local -Dsgm.app.<span class="hljs-attribute">name</span>=market-reduction-center -Dsgm.agent.sink.http.connection.<span class="hljs-attribute">requestTimeout</span>=2000 -Dsgm.agent.sink.http.connection.<span class="hljs-attribute">connectTimeout</span>=2000 -Dsgm.agent.sink.http.<span class="hljs-attribute">minAlive</span>=1 -Dsgm.agent.virgo.<span class="hljs-attribute">address</span>=10.24.216.198:8999,10.223.182.52:8999,10.25.217.95:8999 -Dsgm.agent.<span class="hljs-attribute">zone</span>=m6 -Dsgm.agent.<span class="hljs-attribute">group</span>=m6-discount -Dsgm.agent.<span class="hljs-attribute">tenant</span>=jdjr -Dsgm.deployment.<span class="hljs-attribute">platform</span>=jdt-jdos <span class="hljs-attribute">--add-opens</span>=jdk.management/com.sun.management.internal=ALL-UNNAMED <span class="hljs-attribute">--add-opens</span>=java.management/sun.management=ALL-UNNAMED <span class="hljs-attribute">--add-opens</span>=java.management/java.lang.management=ALL-UNNAMED <span class="hljs-attribute">-DJDOS_DATACENTER</span>=JXQ -Ddeploy.app.<span class="hljs-attribute">name</span>=jdos_kj_market-reduction-center -Ddeploy.app.<span class="hljs-attribute">id</span>=30005051 -Ddeploy.instance.<span class="hljs-attribute">id</span>=0 -Ddeploy.instance.<span class="hljs-attribute">name</span>=server -Djava.awt.<span class="hljs-attribute">headless</span>=<span class="hljs-literal">true</span> -Djava.net.<span class="hljs-attribute">preferIPv4Stack</span>=<span class="hljs-literal">true</span> -Djava.util.Arrays.<span class="hljs-attribute">useLegacyMergeSort</span>=<span class="hljs-literal">true</span> -Dog4j2.<span class="hljs-attribute">contextSelector</span>=org.apache.logging.log4j.core.async.AsyncLoggerContextSelector -Dlog4j2.<span class="hljs-attribute">AsyncQueueFullPolicy</span>=Discard -Xmx12g -Xms12g -XX:<span class="hljs-attribute">MaxMetaspaceSize</span>=256m -XX:<span class="hljs-attribute">MetaspaceSize</span>=256m -XX:<span class="hljs-attribute">MaxDirectMemorySize</span>=2048m -XX:+UseZGC -XX:<span class="hljs-attribute">ZAllocationSpikeTolerance</span>=3 -XX:<span class="hljs-attribute">ParallelGCThreads</span>=8 -XX:<span class="hljs-attribute">CICompilerCount</span>=3 -XX:-RestrictContended -XX:+AlwaysPreTouch -XX:+ExplicitGCInvokesConcurrent -XX:+HeapDumpOnOutOfMemoryError -XX:<span class="hljs-attribute">HeapDumpPath</span>=/export/logs <span class="hljs-attribute">--add-opens</span>=java.base/sun.net.util=ALL-UNNAMED <span class="hljs-attribute">--add-opens</span>=java.base/sun.util.calendar=ALL-UNNAMED <span class="hljs-attribute">--add-opens</span>=java.base/java.util=ALL-UNNAMED <span class="hljs-attribute">--add-opens</span>=java.base/java.math=ALL-UNNAMED <span class="hljs-attribute">--add-opens</span>=java.base/sun.security.action=ALL-UNNAMED <span class="hljs-attribute">--add-opens</span>=java.base/java.lang=ALL-UNNAMED <span class="hljs-attribute">--add-opens</span>=java.base/java.net=ALL-UNNAMED <span class="hljs-attribute">--add-opens</span>=java.base/java.time=ALL-UNNAMED -Dloader.<span class="hljs-attribute">path</span>=/export/package/jdos_kj_market-reduction-center/conf<br></code></pre></td></tr></table></figure><p><strong>3.4  系统验证</strong></p><p>系统可以成功启动后，就可以进行功能验证。有几个验证重点与方法：</p><ul><li><p>首先可以通过单元测试快速进行系统全面回归，避免出现 JDK API、中间件 API 变更导致的业务异常</p></li><li><p>部署到测试环境，验证各个中间件是否正常，如 DUCC 开关下发，MQ 收发，JSF 接口调用等等，系统中所有用到的中间件都需要一一验证</p></li><li><p>然后可以开始进行核心业务的验证，这时候可以利用测试同学的测试自动化能力加人工补充场景，快速进行核心业务回归。其中研发需要观察系统被调用时的所有异常日志，包括警告，明确每条日志产生的原因</p></li><li><p>验证完成后，可以部署到联调环境，利用外部同事联调时的请求进一步进行验证</p></li><li><p>充分在测试环境观察后，部署至预发环境，利用外部同事联调时的请求进一步进行验证，并进行常态化压测，验证优化效果与瓶颈</p></li><li><p>经过预发长时间验证，没有问题后，部署一台生产，通过回放生产流量进一步进行验证</p></li><li><p>回放流量无异常后，开始承接生产流量，按接口开量，进行若干周的观察</p></li><li><p>逐步切量，直到全量上线</p></li></ul><p><strong>04</strong> </p><p> <strong>GC调优</strong> </p><p>理解，首先 MCube 会依据模板缓存状态判断是否需要网络获取最新模板，当获取到模板后进行模板加载，加载阶段会将产物转换为视图树的结构，转换完成后将通过表达式引擎解析表达式并取得正确的值，通过事件解析引擎解析用户自定义事件并完成事件的绑定，完成解析赋值以及事件绑定后进行视图的渲染，最终将目</p><p><strong>4.1  ZGC介绍</strong></p><p><img src="/markdown-img/JDK17%E8%90%A5%E9%94%80%E5%88%9D%E4%BD%93%E9%AA%8C%E2%80%94%E2%80%94%E4%BA%9A%E6%AF%AB%E7%A7%92%E5%81%9C%E9%A1%BFZGC%E8%90%BD%E5%9C%B0%E5%AE%9E%E8%B7%B5.assets/640-20231216215259823.png" alt="图片"></p><p><img src="/markdown-img/JDK17%E8%90%A5%E9%94%80%E5%88%9D%E4%BD%93%E9%AA%8C%E2%80%94%E2%80%94%E4%BA%9A%E6%AF%AB%E7%A7%92%E5%81%9C%E9%A1%BFZGC%E8%90%BD%E5%9C%B0%E5%AE%9E%E8%B7%B5.assets/640-20231216215259800.png" alt="图片"></p><p><img src="/markdown-img/JDK17%E8%90%A5%E9%94%80%E5%88%9D%E4%BD%93%E9%AA%8C%E2%80%94%E2%80%94%E4%BA%9A%E6%AF%AB%E7%A7%92%E5%81%9C%E9%A1%BFZGC%E8%90%BD%E5%9C%B0%E5%AE%9E%E8%B7%B5.assets/640-20231216215259807.png" alt="图片">图4、5、6.ZGC介绍</p><p>如图所示，ZGC 的定位是一个最大暂停时间小于 1ms，且能够处理大小从 8MB 到 16TB 的堆，并且易于调优的垃圾回收器。ZGC 只有三个 STW 阶段，具体流程网上有大量类似文章，这里不做详细介绍。</p><p><strong>4.2  优化方向</strong></p><p>目前本文提到的应用日常使用 G1 约 30ms 的 GC 停顿时间，不到 1 分钟就会触发一次，大促时频率更高，暂停时间更长，导致接口性能波动较大。随着业务发展，为了优化系统大量应用了本地缓存，导致存活对象较多。ZGC 暂停时间不随堆、活动集或根集大小而增加，且极低的 GC 时间正是被需要的特性，因此决定使用 ZGC。</p><p>ZGC 作为一个现代化 GC，没有必要做过多的优化，默认配置已经可以解决 99.9% 的场景。但是应用会承接大促流量，根据观察，瞬时流量激增时 GC 时机较晚，因此应对突发流量是 ZGC 调优的一个目标，其他属性不做任何调整。</p><p><strong>4.3  优化措施</strong></p><p>ZGC 的一个优化措施就是足够大的堆，一般来说，给 ZGC 的内存越多越好，但也没必要浪费，通过压测观察 GC 日志，取得一个合适的值即可。只要保证：</p><ol><li><p>堆可以容纳应用程序产生的实时垃圾</p></li><li><p>堆中有足够的空间，以便在 GC 运行时，为新的垃圾分配提供空间</p></li></ol><p>因此，将机器升级成 8C 16G 配置，观察 GC 日志根据应用情况调整内存占用配置，最终设定为 <code>-Xmx12g -Xms12g -XX:MaxMetaspaceSize=256m -XX:MetaspaceSize=256m -XX:MaxDirectMemorySize=2048m</code>，提升 ZGC 的效果。</p><p>剩下的其他优化措施则视情况而定，可以调整触发 GC 的时机，也可以改为基于固定时间间隔触发 GC。</p><p>略微提升了触发时机，<code>-XX:ZAllocationSpikeTolerance=3</code> （默认为 2）应对突发流量。</p><p><code>CICompilerCount ParallelGCThreads</code> 一个是提升 JIT 编译速度，一个是垃圾收集器并行阶段使用的线程数，根据实际情况略微增加，牺牲一点点 CPU 使用率，提升下效率。</p><p>另外还可以开启 <code>Large Pages</code> 进一步提升性能。这一步没有做，因为现在部署方式为一台物理机 Docker 混部署。开启需要修改内核，影响宿主机的其他镜像。</p><p><strong>05</strong> </p><p> <strong>总结</strong> </p><p>理解，首先 MCube 会依据模板缓存状态判断是否需要网络获取最新模板，当获取到模板后进行模板加载，加载阶段会将产物转换为视图树的结构，转换完成后将通过表达式引擎解析表达式并取得正确的值，通过事件解析引擎解析用户自定义事件并完成事件的绑定，完成解析赋值以及事件绑定后进行视图的渲染，最终将目</p><p>至此，调优完成，目前已在线上跑了一段时间，每周都有三次常态化压测，一切正常。</p><p>以上升级心得分享给大家，希望对各位有所帮助</p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ThreadLocal原理详解</title>
    <link href="/2025/06/29/ThreadLocal%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
    <url>/2025/06/29/ThreadLocal%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="ThreadLocal介绍"><a href="#ThreadLocal介绍" class="headerlink" title="ThreadLocal介绍"></a>ThreadLocal介绍</h1><h2 id="什么是ThreadLocal"><a href="#什么是ThreadLocal" class="headerlink" title="什么是ThreadLocal"></a>什么是ThreadLocal</h2><p>首先，它是一个数据结构，有点像HashMap，可以保存”key : value”键值对，但是一个ThreadLocal只能保存一个，并且各个线程的数据互不干扰</p><h2 id="ThreadLocal和Synchonized"><a href="#ThreadLocal和Synchonized" class="headerlink" title="ThreadLocal和Synchonized"></a>ThreadLocal和Synchonized</h2><p>两者都用于解决多线程并发访问。但是ThreadLocal与synchronized有本质的区别。Synchronized用于线程间的数据共享，而ThreadLocal则用于线程间的数据隔离。Synchronized是利用锁的机制，使变量或代码块在某一时该只能被一个线程访问。而ThreadLocal为每一个线程都提供了变量的副本，使得每个线程在某一时间访问到的并不是同一个对象，这样就隔离了多个线程对数据的数据共享。而Synchronized却正好相反，它用于在多个线程间通信时能够获得数据共享</p><h2 id="ThreadLocal中的key和value"><a href="#ThreadLocal中的key和value" class="headerlink" title="ThreadLocal中的key和value"></a>ThreadLocal中的key和value</h2><p>ThreadLocal实例的弱引用对象会作为key存放在线程的ThreadLocalMap中，然后set方法加入的值就作为ThreadLocalMap中的value，一个线程中可以new多个ThreadLocal用于存放多个值，这些值在线程内是共享的</p><h1 id="为什么要用ThreadLocal保存登录信息？有什么优缺点？"><a href="#为什么要用ThreadLocal保存登录信息？有什么优缺点？" class="headerlink" title="为什么要用ThreadLocal保存登录信息？有什么优缺点？"></a>为什么要用ThreadLocal保存登录信息？有什么优缺点？</h1><p>假设用户登录时请求会被拦截器拦截，提取出当前token中的用户信息（比如userId）放入Context类中。假如userId用的是String类型，那么在高并发的时候，用户A访问系统，此时userId存的是A的userId，如果此时用户B也访问系统，那么userId会被设置成B的userId，此时如果A的业务中需要使用userId，那么拿到的将会是B的userId</p><p>优点：</p><ol><li>线程隔离：每个线程都有自己独立的变量副本，不会受到其他线程的影响，可以避免线程安全问题</li><li>高效性：由于每个线程都有自己的变量副本，不需要进行额外的同步操作，可以提高程序的执行效率</li><li>简单易用：使用 ThreadLocal 可以方便地在多线程环境下管理登录信息，不需要手动进行线程间的变量传递</li></ol><p>缺点：</p><ol><li>内存泄漏：如果没有及时清理 ThreadLocal 中的变量副本，可能会导致内存泄漏问题。因为 ThreadLocal 中的变量副本是与线程绑定的，如果线程一直存在，那么对应的变量副本也会一直存在，可能会占用大量的内存空间</li><li>上下文切换问题：由于每个线程都有自己的变量副本，当需要在多个线程之间共享数据时，可能需要进行额外的上下文切换操作，增加了程序的复杂性和开销</li></ol><h1 id="ThreadLocal的内存泄露问题"><a href="#ThreadLocal的内存泄露问题" class="headerlink" title="ThreadLocal的内存泄露问题"></a>ThreadLocal的内存泄露问题</h1><h2 id="强引用与弱引用"><a href="#强引用与弱引用" class="headerlink" title="强引用与弱引用"></a>强引用与弱引用</h2><p><strong>强引用</strong>，使用最普遍的引用，一个对象具有强引用，不会被垃圾回收器回收。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不回收这种对象</p><p><strong>如果想取消强引用和某个对象之间的关联，可以显式地将引用赋值为null，这样JVM在合适的时间就会回收该对象</strong></p><p><strong>弱引用</strong>，JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在java中，用java.lang.ref.WeakReference类来表示。可以在缓存中使用弱引用</p><h2 id="GC如何找到需要回收的对象"><a href="#GC如何找到需要回收的对象" class="headerlink" title="GC如何找到需要回收的对象"></a>GC如何找到需要回收的对象</h2><p>JVM如何找到需要回收的对象，方式有两种：</p><ul><li>引用计数法：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收</li><li>可达性分析法：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的，那么虚拟机就判断是可回收对象</li></ul><blockquote><p>引用计数法，可能会出现A 引用了 B，B 又引用了 A，这时候就算他们都不再使用了，但因为相互引用 计数器&#x3D;1 永远无法被回收</p></blockquote><h2 id="ThreadLocal内存泄露分析"><a href="#ThreadLocal内存泄露分析" class="headerlink" title="ThreadLocal内存泄露分析"></a>ThreadLocal内存泄露分析</h2><h3 id="ThreadLocal实现原理"><a href="#ThreadLocal实现原理" class="headerlink" title="ThreadLocal实现原理"></a>ThreadLocal实现原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalMap</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;<br>        <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>        Object value;<br><br>        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>            <span class="hljs-built_in">super</span>(k);<br>            value = v;<br>        &#125;<br>    &#125;<br>    ...<br>   &#125;<br></code></pre></td></tr></table></figure><p>ThreadLocal的实现原理，每一个Thread维护一个ThreadLocalMap，key为使用<strong>弱引用</strong>的ThreadLocal实例，value为线程变量的副本。这些对象之间的引用关系如下：</p><p><img src="/markdown-img/ThreadLocal%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3.assets/picturea.png" alt="picturea"></p><blockquote><p>实心箭头表示强引用，空心箭头表示弱引用</p></blockquote><h3 id="ThreadLocal内存泄露原因"><a href="#ThreadLocal内存泄露原因" class="headerlink" title="ThreadLocal内存泄露原因"></a>ThreadLocal内存泄露原因</h3><p>从上图中可以看出，hreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal不存在外部<strong>强引用</strong>时，Key(ThreadLocal)势必会被GC回收，这样就会导致ThreadLocalMap中key为null， 而value还存在着强引用，只有thead线程退出以后,value的强引用链条才会断掉。</p><p>但如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：</p><blockquote><p>Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value</p></blockquote><p>永远无法回收，造成内存泄漏</p><h3 id="为什么使用弱引用而不是强引用"><a href="#为什么使用弱引用而不是强引用" class="headerlink" title="为什么使用弱引用而不是强引用"></a>为什么使用弱引用而不是强引用</h3><p><strong>key 使用强引用</strong></p><p>当threadLocalMap的key为强引用，回收ThreadLocal时，因为ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，导致Entry内存泄漏</p><p><strong>key 使用弱引用</strong></p><p>当ThreadLocalMap的key为弱引用回收ThreadLocal时，由于ThreadLocalMap持有ThreadLocal的弱引用，即使没有手动删除，ThreadLocal也会被回收。当key为null，在下一次ThreadLocalMap调用set()，get()，remove()方法的时候会被清除value值</p><h3 id="ThreadLocalMap的remove-源码分析"><a href="#ThreadLocalMap的remove-源码分析" class="headerlink" title="ThreadLocalMap的remove()源码分析"></a>ThreadLocalMap的remove()源码分析</h3><p>在这里只分析remove()方式，其他的方法可以查看源码进行分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> &#123;<br>    <span class="hljs-comment">//使用hash方式，计算当前ThreadLocal变量所在table数组位置</span><br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//再次循环判断是否在为ThreadLocal变量所在table数组位置</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i];<br>         e != <span class="hljs-literal">null</span>;<br>         e = tab[i = nextIndex(i, len)]) &#123;<br>        <span class="hljs-comment">// 考虑到可能的哈希冲突，一定要准确找到此key对应的entry</span><br>        <span class="hljs-keyword">if</span> (e.get() == key) &#123;<br>            <span class="hljs-comment">//调用WeakReference的clear方法清除对ThreadLocal的弱引用</span><br>            e.clear();<br>            <span class="hljs-comment">//清理key为null的元素</span><br>            expungeStaleEntry(i);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再看看清理key为null的元素expungeStaleEntry(i):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">expungeStaleEntry</span><span class="hljs-params">(<span class="hljs-type">int</span> staleSlot)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br><br>    <span class="hljs-comment">// 将entry的value赋值为null，这样方便GC时将真正value占用的内存给释放出来(不把value置为null也是可以的，但是可能影响GC效率)；将entry赋值为null，size减1，这样这个slot就又可以重新存放新的entry了</span><br>    tab[staleSlot].value = <span class="hljs-literal">null</span>;<br>    tab[staleSlot] = <span class="hljs-literal">null</span>;<br>    size--;<br><br>    Entry e;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-comment">//从staleSlot后一个index开始向后遍历，直到遇到为null的entry</span><br>    <span class="hljs-keyword">for</span> (i = nextIndex(staleSlot, len);<br>         (e = tab[i]) != <span class="hljs-literal">null</span>;<br>         i = nextIndex(i, len)) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br>        <span class="hljs-comment">//如果entry的key为null，则清除掉该entry</span><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;<br>            e.value = <span class="hljs-literal">null</span>;<br>            tab[i] = <span class="hljs-literal">null</span>;<br>            size--;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> k.threadLocalHashCode &amp; (len - <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//key的hash值不等于目前的index，说明该entry是因为有哈希冲突导致向后移动到当前index位置的</span><br>            <span class="hljs-keyword">if</span> (h != i) &#123;<br>                tab[i] = <span class="hljs-literal">null</span>;<br>                <span class="hljs-comment">//对该entry，重新进行hash并解决冲突</span><br>                <span class="hljs-keyword">while</span> (tab[h] != <span class="hljs-literal">null</span>)<br>                    h = nextIndex(h, len);<br>                tab[h] = e;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//返回经过整理后的，位于staleSlot位置后的第一个为null的entry的index值</span><br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>由于Thread中包含变量ThreadLocalMap，因此ThreadLocalMap与Thread的生命周期是一样长，如果都没有手动删除对应key，都会导致内存泄漏。</p><p>但是使用<strong>弱引用</strong>可以多一层保障：弱引用ThreadLocal不会内存泄漏，对应的value在下一次ThreadLocalMap调用set(),get(),remove()的时候会被清除。</p><p>因此，ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动调用对应key的remove方法就会导致内存泄漏，而不是因为弱引用</p><h3 id="ThreadLocal正确使用方法"><a href="#ThreadLocal正确使用方法" class="headerlink" title="ThreadLocal正确使用方法"></a>ThreadLocal正确使用方法</h3><ul><li>每次使用完ThreadLocal都调用它的remove()方法清除数据</li><li>将ThreadLocal变量定义成private static，这样就一直存在ThreadLocal的强引用，也就能保证任何时候都能通过ThreadLocal的弱引用访问到Entry的value值，进而清除掉（如果把ThreadLocal声明为某个类的实例变量（而不是静态变量），那么每创建一个该类的实例就会导致一个新的TSO实例被创建）</li></ul><h1 id="阿里的TTL"><a href="#阿里的TTL" class="headerlink" title="阿里的TTL"></a>阿里的TTL</h1><p><a href="https://github.com/alibaba/transmittable-thread-local">阿里Transmittable-thread-local(Github主页)</a></p><p><code>JDK</code>的<code>InheritableThreadLocal</code>类可以完成父线程到子线程的值传递。但对于使用线程池等会池化复用线程的执行组件的情况，线程由线程池创建好，并且线程是池化起来反复使用的；这时父子线程关系的<code>ThreadLocal</code>值传递已经没有意义，应用需要的实际上是把 <strong>任务提交给线程池时</strong>的<code>ThreadLocal</code>值传递到 <strong>任务执行时</strong></p><p><code>ThreadLocal</code>的需求场景即<code>TransmittableThreadLocal</code>的潜在需求场景，如果你的业务需要『在使用线程池等会池化复用线程的执行组件情况下传递<code>ThreadLocal</code>值』则是<code>TransmittableThreadLocal</code>目标场景</p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>布隆过滤器</title>
    <link href="/2025/06/28/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <url>/2025/06/28/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="1、什么是布隆过滤器"><a href="#1、什么是布隆过滤器" class="headerlink" title="1、什么是布隆过滤器"></a>1、什么是布隆过滤器</h2><p>布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都比一般的算法要好的多，缺点是有一定的误识别率和删除困难。  </p><p>上面这句介绍比较全面的描述了什么是布隆过滤器，如果还是不太好理解的话，就可以把布隆过滤器理解为一个set集合，我们可以通过add往里面添加元素，通过contains来判断是否包含某个元素。由于本文讲述布隆过滤器时会结合Redis来讲解，因此类比为Redis中的Set数据结构会比较好理解，而且Redis中的布隆过滤器使用的指令与Set集合非常类似（后续会讲到）。  </p><p>学习布隆过滤器之前有必要先聊下它的优缺点，因为好的东西我们才想要嘛！</p><p><strong>布隆过滤器的优点：</strong></p><ul><li>时间复杂度低，增加和查询元素的时间复杂为O(N)，（N为哈希函数的个数，通常情况比较小）</li><li>保密性强，布隆过滤器不存储元素本身</li><li>存储空间小，如果允许存在一定的误判，布隆过滤器是非常节省空间的（相比其他数据结构如Set集合）</li></ul><p><strong>布隆过滤器的缺点：</strong></p><ul><li>有点一定的误判率，但是可以通过调整参数来降低</li><li>无法获取元素本身</li><li>很难删除元素</li></ul><h2 id="2、布隆过滤器的使用场景"><a href="#2、布隆过滤器的使用场景" class="headerlink" title="2、布隆过滤器的使用场景"></a>2、布隆过滤器的使用场景</h2><p>布隆过滤器可以告诉我们 <strong>“某样东西一定不存在或者可能存在”，也就是说布隆过滤器说这个数不存在则一定不存，布隆过滤器说这个数存在可能不存在</strong>（误判，后续会讲），利用这个判断是否存在的特点可以做很多有趣的事情</p><ul><li><strong>解决Redis缓存穿透问题（面试重点）</strong></li><li>邮件过滤，使用布隆过滤器来做邮件黑名单过滤</li><li>对爬虫网址进行过滤，爬过的不再爬</li><li>解决新闻推荐过的不再推荐(类似抖音刷过的往下滑动不再刷到)</li><li>HBase\RocksDB\LevelDB等数据库内置布隆过滤器，用于判断数据是否存在，可以减少数据库的IO请求</li></ul><h2 id="3、布隆过滤器的原理"><a href="#3、布隆过滤器的原理" class="headerlink" title="3、布隆过滤器的原理"></a>3、布隆过滤器的原理</h2><h3 id="3-1-数据结构"><a href="#3-1-数据结构" class="headerlink" title="3.1 数据结构"></a>3.1 数据结构</h3><p>布隆过滤器它实际上是一个很长的二进制向量和一系列随机映射函数。以Redis中的布隆过滤器实现为例，Redis中的布隆过滤器底层是<strong>一个大型位数组（二进制数组）+多个无偏hash函数。</strong> </p><p><strong>一个大型位数组（二进制数组）</strong>：</p><p><img src="/markdown-img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.assets/e94e504adc5a75a2d7f562dc44166511.png" alt="位数组.png"></p><p><strong>多个无偏hash函数：</strong></p><p>无偏hash函数就是能把元素的hash值计算的比较均匀的hash函数，能使得计算后的元素下标比较均匀的映射到位数组中。</p><p>如下就是一个简单的布隆过滤器示意图，其中k1、k2代表增加的元素，a、b、c即为无偏hash函数，最下层则为二进制数组。</p><p><img src="/markdown-img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.assets/9ebde5c11ad69447314c216acf188fc8.png" alt="布隆过滤器.png"></p><h3 id="3-2-空间计算"><a href="#3-2-空间计算" class="headerlink" title="3.2 空间计算"></a>3.2 空间计算</h3><p>在布隆过滤器增加元素之前，首先需要初始化布隆过滤器的空间，也就是上面说的二进制数组，除此之外还需要计算无偏hash函数的个数。布隆过滤器提供了两个参数，分别是预计加入元素的大小n，运行的错误率f。布隆过滤器中有算法根据这两个参数会计算出二进制数组的大小l，以及无偏hash函数的个数k<br>它们之间的关系比较简单：</p><ul><li>错误率越低，位数组越长空间件占用较大</li><li>错误率越低，无偏hash函数越多，计算耗时较长</li></ul><p><strong>如下地址是一个免费的布隆过滤器在线计算的网址：</strong></p><blockquote><p><a href="https://krisives.github.io/bloom-calculator/">https://krisives.github.io/bloom-calculator/</a></p></blockquote><p><img src="/markdown-img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.assets/d9cce086a7b9da8afeeb752bdbe8f96e.png" alt="image.png"></p><h3 id="3-3-增加元素"><a href="#3-3-增加元素" class="headerlink" title="3.3 增加元素"></a>3.3 增加元素</h3><p>往布隆过滤器增加元素，添加的key需要根据k个无偏hash函数计算得到多个hash值，然后对数组长度进行取模得到数组下标的位置，然后将对应数组下标的位置的值置为1</p><ul><li>通过k个无偏hash函数计算得到k个hash值</li><li>依次取模数组长度，得到数组索引</li><li>将计算得到的数组索引下标位置数据修改为1</li></ul><p>例如，key &#x3D; Liziba，无偏hash函数的个数k&#x3D;3，分别为hash1、hash2、hash3。三个hash函数计算后得到三个数组下标值，并将其值修改为1，如图所示：</p><p><img src="/markdown-img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.assets/a3e7d217ecb825e94bdc577a467eb29d.png" alt="增加元素.png"></p><h3 id="3-4-查询元素"><a href="#3-4-查询元素" class="headerlink" title="3.4 查询元素"></a>3.4 查询元素</h3><p>布隆过滤器最大的用处就在于判断某样东西一定不存在或者可能存在，而这个就是查询元素的结果。其查询元素的过程如下：</p><ul><li>通过k个无偏hash函数计算得到k个hash值</li><li>依次取模数组长度，得到数组索引</li><li>判断索引处的值是否全部为1，如果全部为1则存在（这种存在可能是误判），如果存在一个0则必定不存在</li></ul><p><strong>关于误判</strong>，其实非常好理解，hash函数再怎么好，也无法完全避免hash冲突，也就是说可能会存在多个元素计算的hash值是相同的，那么它们取模数组长度后的到的数组索引也是相同的，这就是误判的原因。例如李子捌和李子柒的hash值取模后得到的数组索引都是1，但其实这里只有李子捌，如果此时判断李子柒在不在这里，误判就出现啦！因此布隆过滤器最大的缺点误判只要知道其判断元素是否存在的原理就很容易明白了！</p><h3 id="3-5-修改元素"><a href="#3-5-修改元素" class="headerlink" title="3.5 修改元素"></a>3.5 修改元素</h3><p>无  </p><h3 id="3-6-删除元素"><a href="#3-6-删除元素" class="headerlink" title="3.6 删除元素"></a>3.6 删除元素</h3><p>布隆过滤器对元素的删除不太支持，目前有一些变形的特定布隆过滤器支持元素的删除！关于为什么对删除不太支持，其实也非常好理解，hash冲突必然存在，删除肯定是很苦难的！  </p><h2 id="4、Redis集成布隆过滤器"><a href="#4、Redis集成布隆过滤器" class="headerlink" title="4、Redis集成布隆过滤器"></a>4、Redis集成布隆过滤器</h2><h3 id="4-1-版本要求"><a href="#4-1-版本要求" class="headerlink" title="4.1 版本要求"></a>4.1 版本要求</h3><ul><li><strong>推荐版本6.x，最低4.x版本，可以通过如下命令查看版本：</strong></li></ul><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbscript">redis-<span class="hljs-built_in">server</span> -v<br></code></pre></td></tr></table></figure><p><img src="/markdown-img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.assets/6e773444634fc627a5aaab6263fbf848.png" alt="image.png"></p><ul><li><strong>插件安装，网上大部分推荐v1.1.1，文章写的时候v2.2.6已经是release版本了，用户自己选择，地址全在下面(2.2.6官网介绍说是1.0版本的维护版本，如果不想使用新的功能，无需升级！)</strong></li></ul><p><img src="/markdown-img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.assets/f57516a57df20da8b8aa92145e72ce62.png" alt="image.png"></p><p><strong>v1.1.1</strong></p><blockquote><p><a href="https://github.com/RedisLabsModules/rebloom/archive/v1.1.1.tar.gz">https://github.com/RedisLabsModules/rebloom/archive/v1.1.1.tar.gz</a></p></blockquote><p><strong>v2.2.6</strong></p><blockquote><p><a href="https://github.com/RedisLabsModules/rebloom/archive/v2.2.6.tar.gz">https://github.com/RedisLabsModules/rebloom/archive/v2.2.6.tar.gz</a></p></blockquote><h3 id="4-2-安装-编译"><a href="#4-2-安装-编译" class="headerlink" title="4.2 安装&amp;编译"></a>4.2 安装&amp;编译</h3><p>以下安装全部在指定目录下完成，可以选择一个合适的统一目录进行软件安装和管理</p><p><strong>4.2.1 下载插件压缩包</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cobol">wget https://github.com/RedisLabsModules/rebloom/archive/v2.2.6.tar.gz<br></code></pre></td></tr></table></figure><p><strong>4.2.2 解压</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cobol">tar -zxvf v2.2.6.tar.gz<br></code></pre></td></tr></table></figure><p><strong>4.2.3 编译插件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cobol">cd RedisBloom-2.2.6/make<br></code></pre></td></tr></table></figure><p><img src="/markdown-img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.assets/f11054f4f831b629a46b3d4e727b4c6d.png" alt="image.png"></p><p>编译成功后看到redisbloom.so文件即可  </p><h3 id="4-3-Redis集成"><a href="#4-3-Redis集成" class="headerlink" title="4.3 Redis集成"></a>4.3 Redis集成</h3><p><strong>4.3.1 Redis配置文件修改</strong></p><ul><li>在<strong>redis.conf配置文件</strong>中加入如RedisBloom的redisbloom.so文件的地址</li><li>如果是<strong>集群</strong>则每个配置文件中都需要加入redisbloom.so文件的地址</li><li>添加完成后需要<strong>重启redis</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">loadmodule /usr/local/soft/RedisBloom-<span class="hljs-number">2.2</span><span class="hljs-number">.6</span>/redisbloom.so<br></code></pre></td></tr></table></figure><p><strong>redis.conf配置文件中预置了loadmodule的配置项，我们可以直接在这里修改，后续修改会更加方便。</strong></p><p><img src="/markdown-img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.assets/f69019f455492424ccb0fb7082ceb677.png" alt="image.png"></p><p>保存退出后一定要记得重启Redis！</p><p><strong>4.3.2 测试是否成功</strong></p><p>Redis集成布隆过滤器的主要指令如下：</p><ul><li>bf.add 添加一个元素</li><li>bf.exists 判断一个元素是否存在</li><li>bf.madd 添加多个元素</li><li>bf.mexists 判断多个元素是否存在</li></ul><p>连接客户端进行测试，如果指令有效则证明集成成功</p><p><img src="/markdown-img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.assets/93ff2593a25df2d2e0df237eb54ee2ab.png" alt="image.png"></p><p>如果出现如下情况(error) ERR unknown command ，可以通过如下方法检查：</p><ul><li>SHUTDOWN Redis实例，再重启实例，再次测试</li><li>检查配置文件是否配置redisbloom.so文件地址正确</li><li>检查Redis的版本是否过低</li></ul><p><img src="/markdown-img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.assets/0e82b96e2fe2f9bc869f10a0709a8677.png" alt="image.png"></p><h2 id="5、Redis中布隆过滤器指令使用"><a href="#5、Redis中布隆过滤器指令使用" class="headerlink" title="5、Redis中布隆过滤器指令使用"></a>5、Redis中布隆过滤器指令使用</h2><h3 id="5-1-bf-add"><a href="#5-1-bf-add" class="headerlink" title="5.1 bf.add"></a>5.1 bf.add</h3><p>bf.add表示添加单个元素，添加成功返回1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; bf.add name <span class="hljs-title function_">liziba</span><br><span class="hljs-params">(integer)</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><img src="/markdown-img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.assets/3c51b61f0d3eb3cb36e5bd0dd00c1b97.png" alt="image.png"></p><h3 id="5-2-bf-madd"><a href="#5-2-bf-madd" class="headerlink" title="5.2 bf.madd"></a>5.2 bf.madd</h3><p>bf.madd表示添加多个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; bf.madd name liziqi lizijiu lizishi<br><span class="hljs-number">1</span>) (integer) <span class="hljs-number">1</span><br><span class="hljs-number">2</span>) (integer) <span class="hljs-number">1</span><br><span class="hljs-number">3</span>) (integer) <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><img src="/markdown-img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.assets/c0979853a63483b4b96a64013e24c216.png" alt="image.png"></p><h3 id="5-3-bf-exists"><a href="#5-3-bf-exists" class="headerlink" title="5.3 bf.exists"></a>5.3 bf.exists</h3><p>bf.exists表示判断元素是否存在，存在则返回1，不存在返回0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cobol">127.0.0.1:6379&gt; bf.mexists name liziba1) (integer) 1<br></code></pre></td></tr></table></figure><p><img src="/markdown-img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.assets/4f483f31376dc8f1d60445e1be00c5d6.png" alt="image.png"></p><h3 id="5-3-bf-mexists"><a href="#5-3-bf-mexists" class="headerlink" title="5.3 bf.mexists"></a>5.3 bf.mexists</h3><p>bf.mexists表示判断多个元素是否存在，存在的返回1，不存在的返回0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; bf.mexists name liziba<br><span class="hljs-number">1</span>) (integer) <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><img src="/markdown-img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.assets/d5c0a83cd3b23fdb566537a5baeebaa1.png" alt="image.png"></p><h2 id="6、Java本地内存使用布隆过滤器"><a href="#6、Java本地内存使用布隆过滤器" class="headerlink" title="6、Java本地内存使用布隆过滤器"></a>6、Java本地内存使用布隆过滤器</h2><p>使用布隆过滤器的方式有很多，还有很多大佬自己手写的，我这里使用的是谷歌guava包中实现的布隆过滤器，这种方式的布隆过滤器是在本地内存中实现。</p><h3 id="6-1-引入pom依赖"><a href="#6-1-引入pom依赖" class="headerlink" title="6.1 引入pom依赖"></a>6.1 引入pom依赖</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;  <br>      &lt;groupId&gt;com.google.guava&lt;/groupId&gt;    &lt;artifactId&gt;guava&lt;/artifactId&gt;  <br>      &lt;version&gt;<span class="hljs-number">29.0</span>-jre&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h3 id="6-2-编写测试代码"><a href="#6-2-编写测试代码" class="headerlink" title="6.2 编写测试代码"></a>6.2 编写测试代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lizba.bf;<br> <br><span class="hljs-keyword">import</span> com.google.common.hash.BloomFilter;<br><span class="hljs-keyword">import</span> com.google.common.hash.Funnels;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> *        布隆过滤器测试代码</span><br><span class="hljs-comment"> * &lt;/p&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Liziba</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2021/8/29 14:51</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BloomFilterTest</span> &#123;<br> <br>    <span class="hljs-comment">/** 预计插入的数据 */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Integer</span> <span class="hljs-variable">expectedInsertions</span> <span class="hljs-operator">=</span> <span class="hljs-number">10000000</span>;<br>    <span class="hljs-comment">/** 误判率 */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Double</span> <span class="hljs-variable">fpp</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.01</span>;<br>    <span class="hljs-comment">/** 布隆过滤器 */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> BloomFilter&lt;Integer&gt; bloomFilter = BloomFilter.create(Funnels.integerFunnel(), expectedInsertions, fpp);<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 插入 1千万数据</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; expectedInsertions; i++) &#123;<br>            bloomFilter.put(i);<br>        &#125;<br> <br>        <span class="hljs-comment">// 用1千万数据测试误判率</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> expectedInsertions; i &lt; expectedInsertions *<span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (bloomFilter.mightContain(i)) &#123;<br>                count++;<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;一共误判了：&quot;</span> + count);<br> <br>    &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-3-测试结果"><a href="#6-3-测试结果" class="headerlink" title="6.3 测试结果"></a>6.3 测试结果</h3><p>误判了100075次，大概是expectedInsertions（1千万）的0.01，这与我们设置的 <em>fpp</em> &#x3D; 0.01非常接近</p><p><img src="/markdown-img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.assets/dfac339413b1b414a07dd6841f25f624.png" alt="image.png"></p><h3 id="6-4-参数说明"><a href="#6-4-参数说明" class="headerlink" title="6.4 参数说明"></a>6.4 参数说明</h3><p>在guava包中的BloomFilter源码中，构造一个BloomFilter对象有四个参数：</p><ul><li><strong>Funnel funnel：</strong>数据类型，由Funnels类指定即可</li><li><strong>long expectedInsertions：</strong>预期插入的值的数量</li><li><strong>fpp：</strong>错误率</li><li><strong>BloomFilter.Strategy：</strong>hash算法</li></ul><h3 id="6-5-fpp-expectedInsertions"><a href="#6-5-fpp-expectedInsertions" class="headerlink" title="6.5 fpp&amp;expectedInsertions"></a>6.5 fpp&amp;expectedInsertions</h3><ul><li>当expectedInsertions&#x3D;10000000&amp;&amp;fpp&#x3D;0.01时，位数组的大小numBits&#x3D;95850583，hash函数的个数numHashFunctions&#x3D;7</li></ul><p><img src="/markdown-img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.assets/d19ea61540f341245d0a43f6997c94a3.png" alt="image.png"></p><ul><li>当expectedInsertions&#x3D;10000000&amp;&amp;fpp&#x3D;0.03时，位数组的大小numBits&#x3D;72984408，hash函数的个数numHashFunctions&#x3D;5</li></ul><p><img src="/markdown-img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.assets/2452aa80a08537832253d17c9750398d.png" alt="image.png"></p><ul><li>当expectedInsertions&#x3D;100000&amp;&amp;fpp&#x3D;0.03时，位数组的大小numBits&#x3D;729844，hash函数的个数numHashFunctions&#x3D;5</li></ul><p><img src="/markdown-img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.assets/e23d57abceb6ff575fdb12b819502f1f.png" alt="image.png"></p><p>综上三次测试可以得出如下结论：</p><ul><li>当预计插入的值的数量不变时，偏差值fpp越小，位数组越大，hash函数的个数越多</li><li>当偏差值不变时，预计插入的中的数量越大，位数组越大，hash函数并没有变化（注意这个结论只是在guava实现的布隆过滤器中的算法符合，并不是说所有的算法都是这个结论，我做了多次测试，确实numHashFunctions在fpp相同时，是不变的！）</li></ul><h2 id="7、Java集成Redis使用布隆过滤器"><a href="#7、Java集成Redis使用布隆过滤器" class="headerlink" title="7、Java集成Redis使用布隆过滤器"></a>7、Java集成Redis使用布隆过滤器</h2><p>Redis经常会被问道缓存击穿问题，比较优秀的解决办法是使用布隆过滤器，也有使用空对象解决的，但是最好的办法肯定是布隆过滤器，我们可以通过布隆过滤器来判断元素是否存在，避免缓存和数据库都不存在的数据进行查询访问！在如下的代码中只要通过bloomFilter.contains(xxx)即可，我这里演示的还是误判率！</p><h3 id="7-1-引入pom依赖"><a href="#7-1-引入pom依赖" class="headerlink" title="7.1 引入pom依赖"></a>7.1 引入pom依赖</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>  &lt;groupId&gt;org.redisson&lt;/groupId&gt;<br>  &lt;artifactId&gt;redisson-spring-boot-starter&lt;/artifactId&gt;<br>  &lt;version&gt;<span class="hljs-number">3.16</span><span class="hljs-number">.0</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h3 id="7-2-编写测试代码"><a href="#7-2-编写测试代码" class="headerlink" title="7.2 编写测试代码"></a>7.2 编写测试代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lizba.bf;<br> <br><span class="hljs-keyword">import</span> org.redisson.Redisson;<br><span class="hljs-keyword">import</span> org.redisson.api.RBloomFilter;<br><span class="hljs-keyword">import</span> org.redisson.api.RedissonClient;<br><span class="hljs-keyword">import</span> org.redisson.config.Config;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> *      Java集成Redis使用布隆过滤器防止缓存穿透方案</span><br><span class="hljs-comment"> * &lt;/p&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Liziba</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2021/8/29 16:13</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisBloomFilterTest</span> &#123;<br> <br>    <span class="hljs-comment">/** 预计插入的数据 */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Integer</span> <span class="hljs-variable">expectedInsertions</span> <span class="hljs-operator">=</span> <span class="hljs-number">10000</span>;<br>    <span class="hljs-comment">/** 误判率 */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Double</span> <span class="hljs-variable">fpp</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.01</span>;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// Redis连接配置，无密码</span><br>        <span class="hljs-type">Config</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Config</span>();<br>        config.useSingleServer().setAddress(<span class="hljs-string">&quot;redis://192.168.211.108:6379&quot;</span>);<br>        <span class="hljs-comment">// config.useSingleServer().setPassword(&quot;123456&quot;);</span><br> <br>        <span class="hljs-comment">// 初始化布隆过滤器</span><br>        <span class="hljs-type">RedissonClient</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> Redisson.create(config);<br>        RBloomFilter&lt;Object&gt; bloomFilter = client.getBloomFilter(<span class="hljs-string">&quot;user&quot;</span>);<br>        bloomFilter.tryInit(expectedInsertions, fpp);<br> <br>        <span class="hljs-comment">// 布隆过滤器增加元素</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; expectedInsertions; i++) &#123;<br>            bloomFilter.add(i);<br>        &#125;<br> <br>        <span class="hljs-comment">// 统计元素</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> expectedInsertions; i &lt; expectedInsertions*<span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (bloomFilter.contains(i)) &#123;<br>                count++;<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;误判次数&quot;</span> + count);<br> <br>    &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-3-测试结果"><a href="#7-3-测试结果" class="headerlink" title="7.3 测试结果"></a>7.3 测试结果</h3><p><img src="/markdown-img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.assets/8ef4dd0de55a1da3d9d66298ddbd9d3f.png" alt="image.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/06/27/hello-world/"/>
    <url>/2025/06/27/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
